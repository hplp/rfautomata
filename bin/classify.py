#!/usr/bin/env python
"""
    The purpose of this program is to read the report file generated by VASIM
    and return the resulting classifications in a separate file.
    ----------------------
    Author: Tom Tracy II
    email: tjt7a@virginia.edu
    University of Virginia
    ----------------------
    17 January 2018
    Version 0.1
"""

# Utility Imports
from optparse import OptionParser

# Import tools
import os

from tools.io import *

# Turn on logging; let's see what all is going on
logging.basicConfig(format='%(asctime)s : %(message)s', level=logging.INFO)


# Read reports, transform, dump to output file
def classify(reports_filename_, transformer_, output_filename_):

    # This dict acts as a map from the cycle index to a list of the reports for that index
    report_map = {}

    # To preserve order, we'll also have a list of report_indexes
    report_indexes = []

    # Read the reports file
    with open(reports_filename_, 'r') as reports:

        for report in reports:

            report_index = int(report.split(':')[0].strip())
            report_code = int(report.split(':')[-1].strip())

            if report_index not in report_indexes:

                report_map[report_index] = [report_code]
                report_indexes.append(report_index)

            else:

                report_map[report_index].append(report_code)


    # Now write the resulting classifications to the output file
    with open(output_filename_, 'w') as output:

        for index in report_indexes:

            # Apply the transformation to each report code at the given index
            classifications = map(transformer_, report_map[index])

            # Now find the MODE(); that's our classification!
            classification = max(classifications, key=classifications.count)

            output.write(str(index) + ':' + str(classification) + '\n')


# Main()
if __name__ == '__main__':

    # Parse Command Line Arguments
    usage = '%prog [options][reports filename]'

    parser = OptionParser(usage)

    parser.add_option('-o', '--output', type='string', dest='output_filename',
                      default='classifications.txt', help='Classifications output file')


    options, args = parser.parse_args()

    # Verify input filename parameter
    if len(args) == 1:

        reports_filename = args[0]

        # Verify that the file exists
        if not os.path.isfile(reports_filename):
            parser.error("No valid reports file; provide <reports filename>")

    else:
        parser.error("No valid reports file; provide <reports filename>")


    # For our current implementation, based on the AP, we had to offset the report codes
    # by 1, because the AP would not return a 0 (the first class)
    transformer = lambda x: x - 1

    classify(reports_filename, transformer, options.output_filename)